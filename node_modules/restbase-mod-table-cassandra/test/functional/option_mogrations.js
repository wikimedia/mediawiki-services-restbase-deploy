"use strict";

// mocha defines to avoid JSHint breakage
/* global describe, it, before, beforeEach, after, afterEach */

var assert = require('assert');
var dbu = require('../../lib/dbutils');
var fs = require('fs');
var makeClient = require('../../lib/index');
var yaml = require('js-yaml');

var testTable0 = {
    version: 0,
    table: 'optionMigrations',
    options: { },
    attributes: {
        title: 'string',
    },
    index: [
        { attribute: 'title', type: 'hash' },
    ],
};

describe('Option migration', function() {
    var db;
    before(function() {
        return makeClient({
            log: function(level, info) {
                if (!/^info|warn|verbose|debug|trace/.test(level)) {
                    console.log(level, info);
                }
            },
            conf: yaml.safeLoad(fs.readFileSync(__dirname + '/../utils/test_client.conf.yaml'))
        })
        .then(function(newDb) {
            db = newDb;
        })
        .then(function() {
            return db.createTable('restbase.cassandra.test.local', testTable0);
        })
        .then(function(response) {
            assert.ok(response, 'undefined response');
            assert.deepEqual(response.status, 201);
        });
    });
    after(function() {
        db.dropTable('restbase.cassandra.test.local', testTable0.table);
    });

    it('Add some basic options', function() {

        // Update the schema:
        // - add options
        testTable0.options = {
            updates: {
                pattern: 'timeseries'
            },
            compression: [{
                algorithm: 'snappy',
                block_size: 1024,
            }]
        };
        // - increment the version
        testTable0.version = 2;

        // Apply the migration
        return db.createTable('restbase.cassandra.test.local', testTable0)

        .then(function() {
            return db.getTableSchema('restbase.cassandra.test.local', testTable0.table);
        })
        .then(function(response) {
            assert.ok(response, 'undefined response');
            assert.deepEqual(response.schema.table, testTable0.table);
            assert.deepEqual(response.schema._backend_version, dbu.CURRENT_BACKEND_VERSION);
            assert.deepEqual(response.schema.version, testTable0.version);
        });
    });
});
